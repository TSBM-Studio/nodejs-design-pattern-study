## 왜 갑자기 메세징?

- node의 한계점 - CPU bound 작업에 약하다.
- node는 필연적으로 다른 언어들보다 여러개의 서버를 띄워서 마이크로서비스 형태로 서빙할 가능성이 높음.
- 그래서 메세징 관련된 것을 가르치는 것으로 보여짐.

## 왜 찹터에 zeromq 랑 rabbitmq가 자꾸 나옴? zeromq가 무슨 듣보잡임?

broker vs p2p 패턴을 설명하고자 자꾸 등장하는 것임. (이런 선택지가 있고, 설계가 이렇게 달라진다)

zeromq는 node에서 p2p messaging 구현하는 가장 대표적인 방법. 레이턴시 낮아야하는 금융, 게임 서버, 분산 컴퓨팅에서 유명. (성능/제어 최우선) zeromq는 브로커가 아님. 그냥 p2p 메시징 라이브러리임.

rabbitmq는 node에서 broker messaging 구현하는 가장 대표적인 방법. 전통적 메세지 브로커.

세 번째 축으로 redis도 등장함. redis pub sub은 사실상 신뢰성 있는 메세징 시스템은 아님. redis stream은 신뢰성 있는 append-only log 기반 메세징은 맞음. kafka-lite에 가까움. 비전통적 메세지 브로커.

## 9가지 조합.

1. 메시지 교환 패턴 (What / Semantics)

- Publish / Subscribe
- Task Distribution
- Request / Reply

2. 아키텍처 방식 (How / Topology)

- Peer-to-peer
- Broker-based
- Broker-based (Stream)

교환 패턴과 아키텍처 조합하면 9가지가 나옴.

| 조합 | 메시지 패턴         | 아키텍처        | 사용 빈도  | 주요 용도                        | 대표 기술                            |
| ---- | ------------------- | --------------- | ---------- | -------------------------------- | ------------------------------------ |
| 1    | Publish / Subscribe | Broker          | ⭐⭐⭐⭐⭐ | 이벤트 전파, 상태 변경 알림      | Kafka, Redis Pub/Sub, RabbitMQ       |
| 2    | Task Distribution   | Broker          | ⭐⭐⭐⭐⭐ | 비동기 작업, 백그라운드 처리     | SQS, RabbitMQ, BullMQ                |
| 3    | Request / Reply     | Peer-to-peer    | ⭐⭐⭐⭐   | API 호출, DB 쿼리                | HTTP, REST, gRPC                     |
| 4    | Publish / Subscribe | Broker (Stream) | ⭐⭐⭐     | 이벤트 스트리밍, 리플레이        | Kafka, Pulsar, Kinesis, Redis Stream |
| 5    | Request / Reply     | Broker          | ⭐⭐       | 비동기 요청/응답                 | Reply Queue, Correlation ID          |
| 6    | Task Distribution   | Peer-to-peer    | ❌         | 워커 관리 어려움, 실패 처리 난해 | ZeroMQ PUSH/PULL                     |
| 7    | Publish / Subscribe | Peer-to-peer    | ❌         | 구독자 관리 불가능, 확장성 낮음  | ZeroMQ PUB/SUB                       |
| 8    | Task Distribution   | Broker (Stream) | ❌         | 로그를 제어 흐름으로 = 타협적    | Kafka, Pulsar, Kinesis, Redis Stream |
| 9    | Request / Reply     | Broker (Stream) | ❌         | latency, coupling, 복잡도        | Kafka, Pulsar, Kinesis, Redis Stream |

핵심 인사이트

- 1번에서의 rabbitmq와 2번에서의 rabbitmq의 차이점: 1번에서는 fan-out을 하고, 2번에서는 한 번 소비되면 사라짐. (n번 소비되지 않음.) => task distribution인지 바로 와닿는 대목. => 1번에서는 exchange + multi queue, 2번에서는 하나의 queue만 사용.
- 3번은 우리가 알던 그 http가 맞음.
- 4번 stream은 이름 때문에 헷갈리는데, gRPC 같은 거에 스트림으로 연결받는 걸 말하는게 아님.
  - Stream = 삭제되지 않는 메시지 로그를 시간순으로 계속 쌓아두는 것 (Message Stream)
  - 그냥 pubsub이랑 도대체 무슨 차이죠? => 일반적인 pub/sub은 히스토리를 보장하지 않는 경우가 많다. stream은 특정 시간의 과거로 부터 다시 히스토리를 읽어서 이벤트를 모두 리플레이할 수 있음.

## 책 예시를 모아보자

### Using Redis as a simple message broker (1번)

- redis pubsub은 일부러 아주 가볍게 설계된 시스템이다.
  - 이미 캐싱에 쓰고 있는 회사 많아서 쓰기 부담이 적다.
  - 아주 쉬운 구조를 제공하기에 부담이 적다.
  - 그래서 인기가 많다.

### Peer-to-peer Publish/Subscribe with ZeroMQ (7번)

- 이론 소개로는 맞지만, 실무 적용 범위는 매우 좁음.
- '통제된 환경의 고성능 이벤트 배포’로 쓴다고함.
- 위에 표에서는 X처리되어있음.
- zeromq는 udp위에서 도나? 보통은 아님.
  - tcp:// ✅ 기본 / 가장 많이 쓰임
  - ipc:// (Unix domain socket, 같은 머신)
  - inproc:// (같은 프로세스 내)
  - pgm:// / epgm:// (⚠️ 이게 UDP 기반)
- 하지만 tcp위에서 udp와 비슷하게 메세징을 함.
  - ZeroMQ pub/sub의 구조:
    - publisher는 구독자가 몇 명인지 모름
    - subscriber는 publisher가 살아있는지도 모름
    - 연결이 잠깐 끊기면:
      - 메시지 유실 ✔
      - 재전송 ❌
      - 히스토리 ❌
      - 👉 일반적인 “이벤트 시스템”으로는 거의 사용 불가

### Implementing a history service using AMQP (1번)

- ZeroMQ는 사실상 연결/메세지 처리 보장이 안되기 때문에 책에서 Queue를 써보자고 함.
- AMQP(rabbitmq의 프로토콜)는 훨씬 복잡하지만 메세지 처리 완료 ACK를 받을 떄까지 Queue에 남아있기 때문에 메세지 처리 보장이 됨.

### Implementing the chat application using Redis Streams (4번)

- Kafka와 Kinesis가 가장 유명하지만 가벼운 태스크 예시로는 Redis Streams가 좋다며 책에서는 Redis Stream 예시를 가져옴.
- 위에 섹션에서 언급한대로 Stream 방식은 MQ(AMQP) 방식과 많이 다름. 로그를 적어두는 방식임.
- Streams를 써야 할 때는 언제?
  - 순서가 중요한 데이터
  - 과거를 다시 봐야 하는 경우
  - 배치 처리 / 상관관계 분석이 필요한 경우
- 그럼 현대 아키텍처는 진짜 Kafka만 쓰나?
  - ❌ 아니다
  - ⭕ Kafka + RabbitMQ (or SQS) 조합이 제일 흔함
  - 왜냐?
  - Kafka의 본질
    - Event Log
    - 데이터 파이프라인
    - 분석 / 스트리밍 / 리플레이
  - RabbitMQ의 본질
    - Work Queue
    - 시스템 통합
    - 비즈니스 작업 실행
- 현대 아키텍처 실제 그림

  - 흔한 조합

    ```
    [API 서버]
      │
      ├─ (작업) → RabbitMQ / SQS → Worker
      │
      └─ (이벤트) → Kafka → Analytics / Search / ML
    ```

  - 결제 완료 이벤트 → Kafka
  - 이메일 발송 작업 → RabbitMQ
  - 이미지 리사이즈 → Queue
  - 클릭 로그 → Kafka
  - 👉 이걸 전부 Kafka로 하면?
  - 가능은 한데
  - 운영 지옥 + 개념 꼬임
  - “Kafka로 Task Queue 안 되냐?”에 대한 현실 답변 => 된다. 근데 그렇게 할 이유가 거의 없다.
    - retry 직접 구현
    - DLQ 직접 구현
    - priority 불가 (Queue에서 당연한 것: 높은 우선순위 먼저, 일부 작업 5분 뒤에 처리 등)
    - delay 불가
  - 그래서 실무에서 Kafka Task Queue는:
    - “이미 Kafka밖에 없는 조직”
    - “초대규모 단순 작업”
    - 같은 특수 케이스임.

- 그럼 왜 큰 회사들은 Kafka로 “다 해버리는 것처럼” 보일까?

  - 이유 1️⃣: 이벤트와 작업의 경계가 흐려짐
    - “결제 완료 이벤트”
    - “결제 후 처리 작업”
    - 👉 처음엔 이벤트, 그리고 그 뒤에 붙는 건 작업
    - 그래서 Kafka 하나로 묶어버림
  - 이유 2️⃣: 이미 Kafka가 중심에 있음
    - Kafka 운영팀 있음
    - 관측/모니터링 있음
    - ACL / 보안 있음
    - 👉 새로운 MQ 들이는 비용이 더 큼
  - 이유 3️⃣: 단순 작업은 Kafka로도 충분
    - priority 필요 없음
    - delay 필요 없음
    - 실패해도 재처리 가능
    - 👉 그럼 Kafka로 퉁침

- 내 생각:

  - kafka는 inbox, outbox 패턴으로 보통 구현되기 때문에 dlq가 애초에 필요 없긴함.
  - kafka에서는 priority 구현을 그냥 토픽으로 해버린다고함. 실무에서 안써봐서 잘 모르겠음.
    ```
    order.high
    order.normal
    order.low
    ```
  - delay도 topic으로 구현 가능하긴한데, 훨씬 지저분함.

    ```
    task
    → task.delay.1m
    → task.delay.10m
    → task.dlq
    ```

- 결론:
  Kafka가 어색해지는 순간:
  - 긴 delay (몇 시간~며칠)
  - 진짜 우선순위 (긴급 작업)
  - 정밀한 재시도 정책
  - 👉 Queue 병행이 낫다

### Building a distributed hashsum cracker with ZeroMQ (6번)

=> 노드에서 cpu bound한거 분리해서 처리하는거 보여주려고 cpu bound 작업을 예시로 만든듯함 (hashsum craker)

- 어떤 예제?
  - 큰 파일의 해시를 여러 워커에게 나눠서 계산
  - master ↔ worker 직접 통신
  - ZeroMQ PUSH / PULL 패턴 사용
- 의도
  - "Broker 없이도 작업 분산은 가능하다" 보여주기
  - ZeroMQ의 성능/단순함 강조
- 하지만...
  - 워커 실패 시?
  - 중복 실행?
  - 재시도?
  - 워커 수 늘어나면?
  - 👉 전부 직접 구현해야 함
- 핵심 메시지
  - P2P Task Distribution은 가능은 하지만
  - 실무에서는 거의 쓰지 않는다

### Implementing the hashsum cracker using AMQP (2번)

- 뭐가 달라졌나?
  - ZeroMQ → RabbitMQ
  - worker는 queue에서 작업을 가져감
  - ACK 기반 처리
- 얻는 것
  - 워커 죽으면 메시지 재분배
  - backpressure 자동
  - 스케일 아웃 쉬움
- 핵심 메시지
  - 같은 문제라도 Broker를 쓰면
  - "운영 난이도"가 급격히 내려간다
  - 즉: 6번(ZeroMQ) vs 2번(AMQP)을 대조하려고 넣은 예제

### Implementing the hashsum cracker using Redis Streams (8번)

- 의도
  - "Stream으로도 task distribution이 되긴 한다" 보여주기
- 어떻게?
  - consumer group
  - pending entries
  - ack
- 하지만...
  - priority 없음
  - delay 없음
  - routing 없음
  - retry 설계 직접 필요
- 핵심 메시지
  - Streams로 작업 큐를 만들 수는 있지만
  - 본래 용도는 아니다
  - Kafka Task Queue 이야기랑 정확히 같은 맥락임.

### Implementing the Return Address pattern in AMQP (5번)

- Return Address 패턴이란?
  - 비동기 Request / Reply
  - 요청 보낼 때:
    - reply-to 큐 이름
    - correlation id 포함
  - 응답은 그 큐로 돌아옴
- 언제 쓰나?
  - HTTP처럼 동기 호출 ❌
  - 오래 걸리는 작업
  - 결과는 꼭 받아야 할 때
- 왜 Broker가 필요?
  - 요청자/응답자 직접 연결 ❌
  - 느슨한 결합
  - 장애 시 재처리 가능
- 핵심 메시지
  - Broker를 쓰면
  - Request / Reply도 비동기로 풀 수 있다
