7 찹터 전체 생각:

- 혼자 고민해보기에 좋은 시간이었음.
- 과연 책에서 준 예시들이 엄청 도움이 되었고 enlightening되었나..? 솔직히 모르겠음...
- 대신 책 안보고 혼자+llm이서 주제에 대해 먼저 고민해보고 책 잠깐 보기에는 환기/회고에 좋았음. => 앞으로도 이렇게 하는게 나을수도.

## Factory

핵심: 생성 방식을 감춤(캡슐화)

```ts

// 예시 1 - 분기 처리 캡슐화

// 전
const img = new Image(name);


// 후
function createImage(name) {
  if (name.match(/\.jpg$/)) return new ImageJpeg(name);
  if (name.match(/\.gif$/)) return new ImageGif(name);
  ...
}


// 예시 2 - 분기처리시 예시

const noopProfiler = { start(){}, end(){} };

export function createProfiler(label) {
  if (process.env.NODE_ENV === 'production') {
    return noopProfiler;
  }
  return new Profiler(label);
}
```

처음보자마자 든 생각:
평상시에 의식하면서 쓰던 패턴은 아닌 것 같다.
어쩌면 로그 모듈 같은거 만들 때..?
아니면 완전 공통 함수 같은것 만들 때...?

꼭 분기가 있어야되나..??

```ts
function createDBConnection() {
  const conn = new Database();
  conn.connect();
  conn.loadConfig();
  return conn;
}
```

이런것도 팩토리 패턴이라고 한다. 캡슐화가 되기 때문에. 어쩌면 스펙트럼이 존재할수도.

도메인 엔티티도 보통 팩토리인가 그러면? 사실상 모든 클래스는 팩토리인가

```ts
// factory x
class User {
  static create(name: string, age: number) {
    // 유효성 검사
    if (!name) throw new Error("invalid name");
    return new User(name, age);
  }
}

// factory o
class UserFactory {
  constructor(private idGenerator: IdGenerator) {}

  create(name: string) {
    const id = this.idGenerator.generate();
    return new User(id, name);
  }
}

// factory o - 해규님, 창민님 아이디어
class User {
  private constructor() {
    // private으로 외부 new 생성 방지
    // js의 public한 생성자를 막음.
  }

  static create(name: string, age: number) {
    // 유효성 검사
    if (!name) throw new Error("invalid name");
    return new User(name, age);
  }
}
```

위는 llm에게 받은 예시이다.
아 이 예시를 보고 생각났다!
나도 원래 팩토리를 많이 썼던 것 같다.

나의 예시

```ts
const careerFilter = filterFactory({
  preFilter: (items: GQLCareerDTO[], filter: CareerFilterInput) => {
    if (!filter.type) return items;
    return items.filter((item) => item.type === filter.type);
  },
});

export const filterFactory = <T, K extends CommonFilterInput>({
  preFilter,
  postFilter,
}: {
  preFilter?: (items: T[], filter: K) => T[];
  postFilter?: (items: T[], filter: K) => T[];
} = {}) => {
  return (items: T[], filter?: K) => {
    if (!filter) return items;
    const pipeline = [preFilter, commonFilter, postFilter].filter(Boolean) as ((
      items: T[],
      filter: K
    ) => T[])[];
    let result = items;
    pipeline.forEach((fn) => {
      result = fn(result, filter);
    });
    return result;
  };
};

// 외에 이미 십수번 사용한 패턴
```

나의 결론: 팩토리의 정의는 - 단순 객체 x but 단순 객체를 찍어내는 객체 o

- 고민하다보니 이미 알던 패턴이다.
- 예전에는 썼을 때 주로 => 함수를 만드는 함수로 썼었다.

> Decoupling object creation and implementation
> A mechanism to enforce encapsulation

---

gpt와의 대화 발췌 모음

왜 factory 덜 쓰게 된건지에 대한 논의:

- TS로 오면서 덕타이핑(Duck typing)을 덜 쓰게 됨 → 패턴 필요성 감소
- TS/ES6 클래스 도입 → "팩토리 함수" 대신 클래스 사용 증가
- DI Container/Framework 도입 → Factory 역할을 프레임워크가 대신함

- 패턴 자체가 “사라진 것”이 아니라 “숨겨진 것”
  요즘 라이브러리들은 대부분 내부에서만 패턴을 활용함.
  예:
  Axios 내부 → Factory + Adapter 패턴
  TypeORM → Factory + UnitOfWork
  Prisma → Builder + Factory
  Express middleware 생성기 → Factory 함수
  Fetch API → Builder-like 옵션 객체
  라이브러리가 패턴을 내부적으로 사용하고, 우리는 그냥 호출할 뿐
  → 그래서 패턴을 “쓴 느낌이 안 나는 것”.
  즉, 패턴을 안 쓰는 게 아니라
  패턴을 직접 구현할 일이 줄어든 것.

- “패턴이 필요 없을 정도로 문법이 발전했다”
  JS/TS 환경에서 “객체 생성 문제를 해결하기 위한 다른 방법”들이 생김:
  - Optional params
  - Object literal 옵션
  - Default parameter
  - Named arguments 스타일
  - Destructuring
  - Spread syntax
  - Partial<T> + 타입 보조 도구들

창민님/현준님 의견:

- factory는 위에 언급된 것보다 더 큰 개념임.
- new 사용하거나 of, from 쓰는 Java의 패턴도 팩토리 패턴임.
  - **책 기준: new 를 감싸서 캡슐화하면 => 팩토리 패턴**

해규님 의견:

- static create 함수를 쓰면서 그 객체를 new 로 못 만들게 해야 진짜 캡슐화임.
  - 고전적인 내용: new User => 이건 다른 곳에서는 초기화할 수 없도록 만들어야함. (오로지 create 함수로만 가능해야함.)
- js에서는 그래도 new User이 가능함. 그래서 위에서 llm이 factory x 라고 하지 않았나...

## Builder

```ts
new BoatBuilder()
  .withMotors(2, "Best Motor Co.", "OM123")
  .withSails(1, "fabric", "white")
  .withCabin()
  .hullColor("blue")
  .build();
```

꽤 생소하다... 왜일까?
왜 이 패턴을 한 번도 사용하지 않았을까?

알고보니 접하기는 많이 접하고 있었음... 그저 몰랐을 뿐...
고민해보니, 이렇게 복잡하게 추상화된 유틸성 모듈을 다룰 일이 생각보다 적음.
보통은 비즈니스 로직이 10개 내외가 얽혀서 복잡해짐.
어떻게 보면 아래의 추상화 패턴들은 우리가 지금 개발하는 것 보다 월등히 복잡해서 아래처럼 만들 수 밖에 없던 것으로 생각할수도.

```ts
// 돔 조작할 떄...
$("#box").addClass("active").css("color", "red").attr("data-id", "10").show();
```

```ts
// response 만들 떄...
res
  .status(201)
  .set("Content-Type", "application/json")
  .cookie("token", "abc123")
  .json({ success: true });
```

```ts
// typeorm, prisma도 다 이렇게...
knex("users")
  .where("id", 1)
  .select("name", "email")
  .orderBy("created_at")
  .limit(10);

// 이건 mongoose
User.find({ age: { $gt: 20 } })
  .limit(10)
  .sort("name")
  .select("name email")
  .exec();
```

```ts
// zod, yup, zoi
const schema = yup.object({
  name: yup.string().required(),
  age: yup.number().min(1).max(120),
});
```

```ts
// 테스팅할 때 자주보던 것
superagent
  .post('https://example.com/api/person')
  .send({...})
  .set('accept', 'json')
  .then(...)
```

공통점

- Fluent 체이닝
- 설정값을 계속 누적
- 마지막에 execute(), build(), run(), value(), exec() 등이 호출되어 최종 실행

> ✅ 1. “Fluent Interface” 용어를 만든 사람
> 👉 Martin Fowler(마틴 파울러)
> (소프트웨어 설계 분야에서 가장 유명한 인물 중 하나)
> 그는 2005년에 발표한 <Fluent Interface> 라는 글에서 개념을 공식적으로 정의함.
> Link(참고): martinFowler.com/articles/fluentInterface.html
> (※ 링크는 알려진 문서 정보일 뿐 실제 접속은 ChatGPT 환경에서 불가능)
> ✅ 2. Fluent Interface의 정확한 정의
> Martin Fowler는 Fluent Interface를 아래처럼 정의함:
> “객체의 메서드를 연쇄적으로 호출하여, 읽기 쉬운 Domain-Specific Language처럼 보이도록 만드는 객체 API 스타일.
> 메서드 호출이 자연 언어처럼 흘러가도록 한다.”

## Singleton

너무 많이 쓰던것...
express 쓸 때 특히 의식적으로 많이 사용..
express에서 하다가 결국 nest 로 넘어간 케이스가 많다고 느껴짐.

express에서 보통 두 가지 패턴으로 썼던 것 같은데...

1. 모듈 export 할 때 그냥 만들어서 던지기

- module import 할 떄 모듈 레벨에서 캐싱되어서 자동으로 싱글톤.
- export new ...

2. 특정 함수 내에서 생성되어있는지 확인해보고 안생성되어있으면 싱글턴 생성/초기화

```ts
class User {
  eat() {
    if (!userSingleton) {
      userSingleton = new User();
    }
  }
}
```

## Dependency Inejction

```ts
export class Blog {
  // db는 인터페이스 (덕타이핑)
  constructor(db) {
    // db를 주입받음
    this.db = db;
    this.dbRun = promisify(db.run.bind(db));
    this.dbAll = promisify(db.all.bind(db));
  }
}
```

책에서 제시한 예시는 nest와 닮아있음.

새로울 것이 없음.

근데 나는 콜백 전달도 DI의 일종이라 생각하는데, 그런 개념이 안나와서 조금 아쉬웠음.
