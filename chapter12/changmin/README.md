# Node.js Design Patterns

## Chapter 12 - 확장성과 아키텍처 패턴 (Scalability & Architectural Patterns)

Node.js 애플리케이션을 실제 운영 환경에서 확장 가능하게 만드는 방법과 아키텍처 패턴을 다루는 챕터.

### 핵심 내용: Node.js의 확장성

Node.js는 **"네트워크를 통해 통신하는 분산 시스템"**을 구현하기 위해 태어났으며, 이에 완벽하게 부합하는 특성을 가짐.

- **Node.js의 특성**: 가벼운 런타임과 비동기 I/O 모델 덕분에 수평 확장(Scale-out)에 유리함.
- **확장의 의미**: 애플리케이션 확장은 단순히 더 많은 요청을 처리(용량 증대)하는 것뿐만 아니라, **고가용성(Availability)**과 **오류 내성(Fault Tolerance)**을 달성하기 위한 수단임.

---

## 1. 확장성의 3가지 차원 (The Scale Cube)

확장성을 3차원적인 관점에서 정의한 모델 (Abbott and Fisher).

### 1.1 X축: 복제 (Cloning)

- **개념**: 동일한 애플리케이션 인스턴스를 여러 개 복제하여 부하를 분산함.
- **특징**: 개발 비용이 가장 낮고 구현이 쉬움. Node.js의 단일 스레드 한계를 극복하는 기본 전략.
- **예시**: Cluster 모듈, 다중 서버 + 로드 밸런서.

### 1.2 Y축: 분해 (Decomposition)

- **개념**: 기능이나 서비스 단위로 애플리케이션을 분리함.
- **특징**: 코드 베이스가 분리되어 관리 용이성이 증가하지만, 분산 시스템의 복잡도가 생김.
- **예시**: 마이크로서비스 아키텍처 (MSA).

### 1.3 Z축: 데이터 파티셔닝 (Data Partitioning)

- **개념**: 요청자의 속성(ID, 지역 등)에 따라 특정 인스턴스로 라우팅함.
- **특징**: 각 인스턴스가 전체 데이터의 일부만 처리하도록 하여 DB 병목 등을 해소.
- **예시**: 샤딩(Sharding), 지역별 서버 배치.

---

## 2. 복제 및 로드 밸런싱 (X축 확장)

X축 확장은 Node.js의 단일 스레드 구조에서 필수적임.

### 2.1 Cluster 모듈 (The Cluster Module)

Node.js 내장 모듈로, 단일 머신 내에서 포트를 공유하며 여러 워커 프로세스를 띄우는 방식.

- **동작 원리**: Master 프로세스가 워커를 포크(fork)하고, 들어오는 연결을 워커들에게 분산(Round-Robin 등)함.
- **한계**: 단일 서버 내에서의 확장만 가능하므로, 서버 자체의 장애(정전 등)에는 대응 불가.
- **Zero-downtime Restart**: 워커를 하나씩 재시작하여 서비스 중단 없이 배포/업데이트 가능.

### 2.2 상태 관리 (Dealing with Stateful Communications)

여러 인스턴스로 확장 시, 인스턴스 간 상태 공유 문제가 발생함.

1.  **Sticky Load Balancing**: 특정 사용자의 요청을 항상 같은 인스턴스로 보냄.
    - _단점_: 로드 밸런싱 불균형, 해당 인스턴스 장애 시 세션 소실.
2.  **공유 상태 (Shared State)**: 상태(세션 등)를 Redis와 같은 외부 저장소로 분리. **(권장)**
    - _장점_: 진정한 Stateless 아키텍처 구현 가능, 인스턴스 자유로운 추가/제거.

### 2.3 리버스 프록시를 이용한 확장 (Scaling with a Reverse Proxy)

단일 머신을 넘어 여러 서버로 확장하기 위해 Nginx, HAProxy 같은 리버스 프록시를 사용.

- **역할**: 클라이언트 요청을 받아 백엔드 Node.js 서버들로 분산.
- **장점**: SSL 종단, 정적 파일 서빙, 로드 밸런싱을 통합 관리.

### 2.4 서비스 레지스트리 (Service Registry)

클라우드 환경처럼 인스턴스가 동적으로 변하는 환경에서의 확장.

- **문제**: Auto Scaling으로 IP가 계속 바뀌므로 고정 IP 설정이 불가능.
- **해결**:
  - **Service Registry**: 살아있는 서비스의 위치를 저장하는 DB.
  - **Service Discovery**: 클라이언트나 로드 밸런서가 레지스트리를 조회하여 통신.

---

## 3. 복잡한 애플리케이션 분해 (Y축 확장)

모놀리식 애플리케이션의 한계를 극복하기 위한 마이크로서비스 아키텍처.

### 3.1 모놀리식 vs 마이크로서비스

- **모놀리식**: 개발 초기에는 빠르지만, 규모가 커지면 빌드/배포 시간 증가, 기술 스택 고착화, 장애 전파 등의 문제 발생.
- **마이크로서비스**: 각 서비스가 독립적으로 배포/확장 가능, 기술 스택 유연성, 장애 격리.

### 3.2 통합 패턴 (Integration Patterns)

분리된 서비스들을 연결하는 방법.

1.  **API Gateway**: 모든 클라이언트 요청의 단일 진입점. 라우팅, 인증, 통합 등을 담당.
2.  **Client-side Discovery vs Server-side Discovery**: 서비스 탐색을 누가 수행할 것인가에 대한 패턴.

---

## 결론

Node.js의 확장성은 단순히 "성능 높이기"가 아니라, **시스템을 어떻게 분리하고 연결할 것인가**에 대한 아키텍처 설계의 문제임.

- **X축(복제)**: Stateless하게 만들고 부하를 분산하라.
- **Y축(분해)**: 복잡성을 나누고 서비스 간 결합도를 낮춰라.
- **Z축(파티셔닝)**: 데이터와 트래픽을 속성에 따라 격리하라.
