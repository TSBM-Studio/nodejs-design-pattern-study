# Node.js Design Patterns

## Chapter 2 - 모듈 시스템

Node.js 의 두 가지 모듈 시스템 (CJS, ESM) 에 대해 탐구하는 챕터

- 모듈이 왜 필수적이며 Node.js 에서 다른 모듈시스템이 가능한 이유
- CommonJS 내부와 모듈 패턴
- ESM
- CommonJS와 ESM 사이의 차이점 및 상호 이용

### 핵심 내용

### 추측해보는 저자의 의도

- 모듈의 필요성

코드를 재사용 가능한 단위로 구성해 관리 용이성을 높이고, 네임스페이스 충돌 방지 및 의존성 관리를 위해 필수

- CommonJS (CJS)

Node.js 의 전통적인 동기식 모듈 시스템

```ts
const fs = require("fs");

fs.readFile("example.txt", (err, data) => {
  if (err) {
    console.error(err);
  } else {
    console.log(data);
  }
});
```

`require()` 함수로 모듈을 동기적으로 불러온다.

`module.exports` 또는 `exports` 객체를 통해 모듈 기능을 내보낸다.

모듈 해석 알고리즘 : 코어 -> 파일 -> 패키지(node_modules) 순서로 모듈을 찾는다.

모듈 캐싱 : 한 번 불러온 모듈은 캐시되어 성능 향상

순환 의존성 : 모듈 간 상호 참조 시 불완전한 객체가 로드될 수 있다.

리빌링 모듈 패턴 : 클로저를 이용해 내부 상태를 숨기고 (캡슐화) 제어된 인터페이스만 노출한다.

- ECMAScript Modules (ESM)

javascript 표준 모듈 시스템

```ts
import fs from "fs";

fs.readFile("example.txt", (err, data) => {
  if (err) {
    console.error(err);
  } else {
    console.log(data);
  }
});
```

`import`, `export` 키워드를 사용해 모듈 관계를 정적으로 정의한다. (코드 분석 시점)

명명된(Named)/기본(Default) 내보내기/가져오기를 지원한다.

일기 전용 라이브 바인딩 : 가져온 모듈 변수는 읽기 전용이며, 원본 모듈 값이 변경되면 반영된다.

로딩 단계 : 파싱 -> 인스턴스화 -> 평가의 명확한 단계를 거친다.

비동기 로딩 : `async import()` 를 통해 모듈을 비동기적으로 로드할 수 있다.

CJS보다 순환 의존성을 더 안정적으로 처리한다.

- CJS vs ESM

로딩 방식 : CJS 는 동기, ESM은 정적/비동기

`this` 컨텍스트 : CJS는 모듈 스코프, ESM은 `undefined`

문법 및 유연성 : ESM은 정적 분석에 유리, CJS는 동적으로 유연하게 사용 가능

상호 운용성 : Node.js 에서는 두 시스템을 함께 사용할 수 있는 방법을 제공하지만, 제약과 주의사항 존재한다.

### 추측해보는 저자의 의도

Node.js 를 다루는 개발자가 코드를 체계적으로 구성하고 재사용하는 가장 기본적인 방법으로서 모듈 시스템의 중요성을 강조하고, 그 작동 원리를 이해시키려는 의도로 보인다. 특히, 이전 챕터에서 Node.js 의 근본 철학으로 모듈 관련 내용을 언급했기에 더욱 이 점을 강조하려 한 것으로 보인다.

CJS와 ESM 두 시스템 특징, 장단점, 내부 동작 방식을 비교하여 프로젝트 상황에 맞게 적절한 시스템을 선택하거나 두 시스템을 올바르게 함께 사용할 수 있도록 가이드하는 것으로 생각했다.

모듈 캐싱의 동작 방식이나 특히 순환 의존성과 같은 개발 과정에서 발생할 수 있는 문제와 그 해결책/동작 방식을 설명해 개발자가 모듈 시스템을 효과적으로 사용할 수 있도록 돕기 위한 챕터라고 생각한다.
