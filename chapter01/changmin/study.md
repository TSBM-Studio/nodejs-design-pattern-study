# 비동기 주도 아키텍처와 리액터 패턴 딥다이브

주제 : Node.js 의 비동기 이벤트 주도 아키텍처의 핵심 메커니즘

---

## 일단 내가 알고있는 범위

node.js 는 싱글스레드 기반으로 동작하며, 이벤트 기반 아키텍처, 논블로킹 I/O 모델을 통해 적은 리소스로 좋은 I/O 처리 성능을 보여준다.

싱글스레드? -> node.js 의 libuv는 별도의 I/O 작업 처리를 위해 스레드 풀을 가지고 있지만 이벤트 루프는 메인 스레드 위에서 싱글 스레드로 동작하고 있다.

Node.js 는 이벤트 루프를 중심으로 동작하며, I/O 이벤트를 비동기적으로 처리하고 해당 이벤트에 등록된 콜백을 실행한다.

## 진짜 알고있는 건가?

- 이벤트 기반 아키텍처 -> 이벤트 루프를 사용하니까 이벤트 기반 아키텍처이지 않을까..?
- 싱글스레드를 왜 사용했지? -> 멀티 프로세스/스레드 환경에서보다 자원을 아낄 수 있으니까..?
- 논블로킹 I/O 모델로 적은 리소스로 좋은 성능을 낸다고? -> 그냥 이런 작업들 비동기 처리해버리면 블로킹되지 않아서..?

이 정도까지만 생각해봤고 그 동작이 실제로 어떻게 이루어지는지, 내가 생각해본 내용이 실제로 그렇게 동작하는지와 같은 딥다이브를 해본 적은 없었다. 그래서, 사실 면접을 위한..? 혹은 그냥 궁금해서 조금 찾아본 수준인 것 같다.

## 그럼 딥다이브

### 왜 싱글 스레드인가?

일단 전통적인 서버의 thread-per-connection 모델은 연결 수 증가 시 스레드가 폭증한다. -> 컨텍스트 스위칭/락 관리/메모리 오버헤드 등의 문제로 확장성 X (C10k 문제)

Node.js 에서는 이러한 비용과 문제를 피하기 위해 JS 코드를 하나의 스레드(이벤트 루프)에서 실행시키고, I/O 작업은 커널/백그라운드로 넘기는 방식을 통해 단순하게 설계 -> 메인스레드는 오로지 콜백 처리/JS 코드 실행에만 집중

여기서 굳이 libuv 의 스레드 풀에 대한 이야기를 하자면 OS가 IO 작업에 대해 비동기/논블로킹을 효율적으로 지원하지 않는 특정 작업이나 CPU intensive 한 작업을 처리하기 위해 libuv 는 별도의 스레드 풀(기본 4개)을 사용한다.

핵심은 이 스레드 풀 작업이 메인 스레드 (이벤트 루프)를 블락시키지 않는다는 점이다. 작업 완료 시 이벤트 루프에 콜백을 등록하여 비동기 흐름을 유지한다.

### I/O 멀티플렉싱과 디멀티플렉싱

싱글 스레드 기반에서 I/O 작업 때문에 블로킹되면 아무것도 처리할 수 없게 된다. 그래서 Node.js 는 논블로킹 I/O 를 기본으로 사용한다.

- 논블로킹 I/O 호출 : I/O 작업을 OS에 요청할 때, 완료될 때까지 기다리지 않고 즉시 제어권 반환 (스레드가 해당 작업 호출로 멈추지 않음)
- 문제점 : 그럼 언제 완료되었는지 어떻게 알지? -> 모든 I/O 자원을 계속 폴링하는 건 CPU 리소스 낭비
- 해결책 : I/O 멀티플렉싱 (이벤트 디멀티플렉싱)

libuv 는 OS 커널이 제공하는 I/O 멀티플렉싱 기능(epoll, kqueue, IOCP) 를 사용한다.

이 기능은 하나의 스레드(이벤트 루프)가 여러 개의 I/O 자원을 OS에 등록하고, 그 중 어떤 것이든 이벤트(ex. 데이터 도착)가 발생할 때까지 효율적으로 대기할 수 있게 한다. 이 대기는 CPU 리소스를 거의 사용하지 않는 효율적인 대기 상태이다.

이벤트가 발생하면 OS는 어떤 자원에서 어떤 이벤트가 발생했는지 식별 (디멀티플렉싱) 하여 이벤트 루프에게 알려준다.

### 왜 리액터 패턴을 적용했지?

Node.js 는 싱글 스레드, 논블로킹 I/O, I/O 멀티플렉싱을 효과적으로 조합해 사용하기 위해 리액터 패턴을 아키텍처의 근간으로 채택했다.

- 리액터 패턴 : 하나의 이벤트 루프(Reactor)가 이벤트 디멀티플렉서를 통해 여러 I/O 이벤트를 감지하고, 해당 이벤트를 적절한 핸들러(콜백 함수)에게 디스패치하는 구조

- Node.js 이벤트 루프의 동작

1. 이벤트 대기 : libuv 의 이벤트 루프는 I/O 멀티플렉서를 통해 이벤트 발생을 효율적으로 대기
2. 이벤트 감지 및 큐잉 : 이벤트가 발생하면 디멀티플렉서가 알려주고, 이벤트 루프는 해당 이벤트에 등록된 핸들러(콜백)를 이벤트 큐에 넣음. (Node.js는 실제로 여러 종류의 큐를 사용: TImers, I/O .. + microtask queue + nextTick queue)
3. 핸들러 실행 : 이벤트 루프는 Call stack이 비어있을 때, 정해진 순서에 따라 큐에서 핸들러를 꺼내 Call Stack으로 보내고 실행
4. 반복 : 특정 조건이 될때까지 루프를 무한으로 반복

이게 이벤트 기반 아키텍처의 구체적인 모습이라 생각이 들고, 시스템은 이벤트 발생에 반응(React)하여 동작한다.

## 결론

Node.js는 싱글 스레드의 단순성과 자원 효율성을 유지하면서도, 리액터 패턴을 기반으로 libuv 가 제공하는 이벤트 루프, OS의 I/O 멀티플렉싱, 그리고 필요시 스레드 풀을 활용하여 비동기 논블로킹 I/O 모델을 잘 구현한 것 같다.

이 아키텍처 덕분에 Node.js는 I/O 작업이 많은 환경에서 적은 자원으로도 높은 동시성과 처리량을 달성할 수 있는 강력한 플랫폼이 된게 아닌가 싶다.

## 그런데 JavaScript 코드가 어떻게 C++ 이벤트와 연결되지?

앞서 libuv가 이벤트를 감지하고 콜백을 실행한다고 했는데, 생각해보니 JavaScript와 C++은 완전히 다른 컨텍스트이다. `fs.readFile()` 같은 JavaScript 함수가 어떻게 libuv의 C++ 코드를 호출하고, 다시 JavaScript 콜백으로 돌아올 수 있을까?

### V8과 libuv를 연결하는 바인딩 레이어

Node.js는 JavaScript(V8)와 시스템 레벨 작업(libuv) 사이에 C++ 바인딩 레이어를 두고 있다.

```javascript
// JavaScript에서 호출
fs.readFile("test.txt", (err, data) => {
  console.log(data);
});
```

이 과정을 분해해보면

1. **JavaScript → C++ 변환**

   - V8이 `fs.readFile` 호출을 감지
   - Node.js의 C++ 바인딩 함수가 실행됨
   - JavaScript 인자들(파일명, 콜백)이 C++ 타입으로 변환

2. **비동기 작업 설정**

   ```cpp
   // 실제로는 더 복잡하지만, 핵심만 보면
   static void Read(const FunctionCallbackInfo<Value>& args) {
     String::Utf8Value path(args[0]);  // JS 문자열 → C++ 문자열

     // 콜백을 나중에 사용할 수 있도록 저장
     Persistent<Function> callback(args[1]);

     // libuv에게 파일 읽기 요청
     uv_fs_t* req = new uv_fs_t;
     req->data = &callback;  // 콜백 참조 저장
     uv_fs_read(loop, req, fd, buffer, -1, 0, OnRead);
   }
   ```

3. **작업 완료 후 콜백 실행**

   ```cpp
   static void OnRead(uv_fs_t* req) {
     // V8 컨텍스트 진입 (중요!)
     HandleScope scope(isolate);

     // 저장했던 JavaScript 콜백 가져오기
     Local<Function> callback = Local<Function>::New(isolate,
                                  *static_cast<Persistent<Function>*>(req->data));

     // JavaScript로 결과 전달
     Local<Value> argv[] = {
       Null(isolate),  // err
       Buffer::New(isolate, data, length)  // data
     };

     // JavaScript 콜백 실행!
     callback->Call(context, Null(isolate), 2, argv);
   }
   ```

### 핵심 포인트: HandleScope와 Context

V8은 JavaScript 객체의 생명주기를 관리하기 위해 HandleScope를 사용한다. C++ 코드가 JavaScript 와 상호작용하려면

- **HandleScope**: JavaScript 객체에 대한 참조를 관리하는 스택 기반 메모리 관리
- **Context**: JavaScript 실행 환경 (전역 객체, 내장 객체 등)
- **Persistent Handle**: 비동기 작업 중에도 GC되지 않도록 콜백을 보호

이렇게 복잡한 과정을 거치는 이유는 V8의 가비지 컬렉터가 언제든 JavaScript 객체를 정리할 수 있기 때문이다. 비동기 작업이 진행되는 동안 콜백 함수가 사라지면 안 되니까.

### 왜 이렇게 복잡하게 만들었을까?

- **성능**: JavaScript와 네이티브 코드 간 불필요한 변환 최소화
- **안정성**: 메모리 누수나 크래시 방지
- **유연성**: 다양한 시스템 API를 JavaScript로 노출 가능

이 바인딩 레이어 덕분에 우리는 JavaScript로 시스템 프로그래밍의 강력함을 누릴 수 있는 것이다. JavaScript 개발자는 이 복잡한 과정을 전혀 몰라도 되고, 그저 익숙한 콜백 패턴으로 비동기 I/O를 사용할 수 있다.

## 함께 이야기해보고 싶은 부분

- 비동기/동기/블로킹/논블로킹 IO 를 다들 어떻게 이해하고 구분짓고 있나요?
