# node.js의 철학

## 경량 코어
최소한의 핵심 기능만 두고 나머지는 NPM 패키지로 제공하도록 한다.

## 경량 모듈
각 모듈의 설계를 작고 단일한 기능만 제공하도록 한다.

## 작은 외부 인터페이스
단일 진입점을 제공하기 위해 단 하나의 함수나 클래스를 노출한다.

유스케이스를 줄이고 구현을 단순화 하며, 가용성을 높인다는 장점을 가지고 있음.

## 간결함과 실용주의
단순하게 설계하는 것, 구현에 적은 노력이 들어가고, 빠른 배포를 할 수 있다.

유지보수가 쉽고 빠른 이해가 가능하다.

# node.js는 어떻게 동작하는가

## Blocking I/O
I/O를 요청하는 함수의 호출은 작업이 완료될 때까지 스레드의 실행을 차단함.

해당 스레드가 다른 요청을 받게 되면 처리할 수 없는 상황.

Spring MVC의 경우 Blocking 방식을 사용하고 각각의 요청별로 개별 스레드를 할당함. (Request Per Thread)

스레드는 시스템 리소스 측면에서 저렴하지 않음.

컨텍스트 스위칭을 유발하여 대기 상태의 스레드를 관리하며 메모리와 CPU 사이클을 낭비하게 됨.

## Non-Blocking I/O
I/O를 요청하는 함수의 호출을 즉시 반환하고, 작업이 완료되면 콜백 함수를 호출하여 결과를 처리함.

Non-Blocking을 다루는 가장 기본적인 패턴은 실제 데이터가 반환될 때까지 루프내에서 리소스를 계속 Polling하는 것.

이것을 Busy Waiting이라고 함. 하지만 이 알고리즘은 엄청난 CPU 시간의 낭비를 초래함.

## 이벤트 디멀티플렉싱
운영체제는 Non-Blocking 리소스를 효율적으로 처리하기 위한 기본적인 메커니즘을 제공.

이걸 Synchronous Event Demultiplexer or Event Notification Interface이라고 부름.

멀티플렉싱: 여러 신호들을 하나로 합성하여 제한된 수용범위 내에서 매개체를 통하여 쉽게 전달하는 방법

디멀티플렉싱: 신호가 원래 구성요소로 다시 분할되는 작업

여기서 말하는 Synchronous Event Demultiplexer는 여러 리소스를 관찰하고 이 리소스들 중에 읽기 또는 쓰기 연산의 실행이 완료되었을 때 새로운 이벤트를 반환.

여기서 찾을 수 있는 이점은 Synchronous Event Demultiplexer가 처리하기 위한 새로운 이벤트가 있을 때까지 Blocking 상태로 대기할 수 있다는 것임.

이 패턴을 사용하면 Busy Waiting을 사용하지 않고 여러 I/O 작업을 단일 스레드로 처리할 수 있음.

단일 스레드를 사용하는 것이 동시적 다중 I/O 작업에 나쁜 영향을 미치지 않고 여러 스레드 분산되는 대신에 시간에 따라 분산됨.

또한, 프로그래머가 동시성에 접근하는 방식에 이로운 영향을 미치게 됨.

## Reactor Pattern
