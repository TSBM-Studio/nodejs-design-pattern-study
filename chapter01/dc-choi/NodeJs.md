# 요약
```
Node.js의 설계 철학
최소한의 코어(minimal core)로 구성되어 있음.
확장성과 단순성을 동시에 추구.
불필요한 복잡성을 줄이고 핵심 기능만 내장.

내부 아키텍처 탐구
Node.js의 심장인 Reactor Pattern을 통해 비동기 이벤트 기반 구조를 이해함.
내부적으로 V8 엔진, libuv, Core JS 라이브러리가 어떤 역할을 하는지 살펴봄.
이를 통해 Node.js의 비동기 I/O 처리 메커니즘을 명확히 파악.

Node.js vs 브라우저
두 환경 모두 JavaScript를 사용하지만, Node.js는 브라우저 밖에서 실행되며 파일시스템, 네트워크, 프로세스 제어 등 OS 레벨 접근이 가능하다는 점이 차이.
```

# Node.js의 철학

## 경량 코어
최소한의 핵심 기능만 두고 나머지는 NPM 패키지로 제공하도록 한다.

## 경량 모듈
각 모듈의 설계를 작고 단일한 기능만 제공하도록 한다.

## 작은 외부 인터페이스
단일 진입점을 제공하기 위해 단 하나의 함수나 클래스를 노출한다.

유스케이스를 줄이고 구현을 단순화 하며, 가용성을 높인다는 장점을 가지고 있음.

## 간결함과 실용주의
단순하게 설계하는 것, 구현에 적은 노력이 들어가고, 빠른 배포를 할 수 있다.

유지보수가 쉽고 빠른 이해가 가능하다.

# Node.js는 어떻게 동작하는가

## Blocking I/O
I/O를 요청하는 함수의 호출은 작업이 완료될 때까지 스레드의 실행을 차단함.

해당 스레드가 다른 요청을 받게 되면 처리할 수 없는 상황.

Spring MVC의 경우 Blocking 방식을 사용하고 각각의 요청별로 개별 스레드를 할당함. (Request Per Thread)

스레드는 시스템 리소스 측면에서 저렴하지 않음.

컨텍스트 스위칭을 유발하여 대기 상태의 스레드를 관리하며 메모리와 CPU 사이클을 낭비하게 됨.

## Non-Blocking I/O
I/O를 요청하는 함수의 호출을 즉시 반환하고, 작업이 완료되면 콜백 함수를 호출하여 결과를 처리함.

Non-Blocking을 다루는 가장 기본적인 패턴은 실제 데이터가 반환될 때까지 루프내에서 리소스를 계속 Polling하는 것.

이것을 Busy Waiting이라고 함. 하지만 이 알고리즘은 엄청난 CPU 시간의 낭비를 초래함.

## 이벤트 디멀티플렉싱
운영체제는 Non-Blocking 리소스를 효율적으로 처리하기 위한 기본적인 메커니즘을 제공.

이걸 Synchronous Event Demultiplexer or Event Notification Interface이라고 부름.

멀티플렉싱: 여러 신호들을 하나로 합성하여 제한된 수용범위 내에서 매개체를 통하여 쉽게 전달하는 방법

디멀티플렉싱: 신호가 원래 구성요소로 다시 분할되는 작업

여기서 말하는 Synchronous Event Demultiplexer는 여러 리소스를 관찰하고 이 리소스들 중에 읽기 또는 쓰기 연산의 실행이 완료되었을 때 새로운 이벤트를 반환.

여기서 찾을 수 있는 이점은 Synchronous Event Demultiplexer가 처리하기 위한 새로운 이벤트가 있을 때까지 Blocking 상태로 대기할 수 있다는 것임.

이 패턴을 사용하면 Busy Waiting을 사용하지 않고 여러 I/O 작업을 단일 스레드로 처리할 수 있음.

단일 스레드를 사용하는 것이 동시적 다중 I/O 작업에 나쁜 영향을 미치지 않고 여러 스레드 분산되는 대신에 시간에 따라 분산됨.

또한, 프로그래머가 동시성에 접근하는 방식에 이로운 영향을 미치게 됨.

## Reactor Pattern
이벤트가 발생하면 미리 등록된 핸들러가 그 이벤트를 처리하는 패턴

Node.js에서 핸들러는 콜백 함수이고, 이벤트는 I/O 작업의 완료임.

Event Demultiplexer: OS 레벨에서 이벤트 감시하고 Event Queue에 전달

Event Queue: 준비된 이벤트를 임시 저장

Event Loop: Event Queue를 순회하여 핸들러를 실행

## libuv, Node.js의 I/O 엔진
서로 다른 운영체제 간의 불일치성은 이벤트 디멀티플렉싱을 구현하는데 어려움을 줌.

이를 위해 보다 높은 레벨의 추상화 계층이 필요함.

이런 이유로 인해 Node.js는 libuv라는 C 라이브러리를 사용함.

기본 시스템 호출을 추상화 하는 것 외에도 Reactor Pattern을 구현하고 있음.

1. Event Loop 생성
2. Event Queue 관리
3. 비동기 I/O 작업 실행 및 다른 유형의 작업 Event Queue에 담기 위한 API 제공.

## Node.js를 위한 구성
바인딩 세트: libuv와 다른 저수준 기능을 랩핑하고 표출

V8: JS 엔진

Node.js 코어 라이브러리: fs, net, http 등과 같은 고수준 API 제공

# Node.js에서의 JS
가장 눈에 띄는 차이점은 DOM API가 없고, window, document 객체가 없다는 것.

브라우저에서는 운영체제 접근이 불가능하지만 Node.js에서는 가능.

## 최신 JS를 실행시켜라
브라우저 환경에서는 다양한 장치와 브라우저의 차이 때문에 JS 코드가 동일하게 동작하지 않는 경우가 많음

이런 호환성 문제를 해결하려고 트랜스파일러(Babel 등) 와 폴리필(polyfill) 을 사용하지만, 이것들도 완벽한 해결책은 아니고 단점이 있음.

반면, Node.js 환경은 이미 일정한 런타임(V8 기반) 위에서 실행되기 때문에 코드가 어떤 환경에서 돌아갈지 명확하고, 특정 버전의 ECMAScript 기능을 안정적으로 사용할 수 있음.

즉, 브라우저처럼 환경 차이 때문에 고생할 일이 훨씬 적어요.

Node.js는 최신 V8 엔진을 사용하므로 대부분의 최신 ES 사양을 별도 트랜스파일 과정 없이 바로 쓸 수 있음.

라이브러리를 배포하려는 경우에는 여러 Node.js 버전(LTS 포함)에서 실행될 수 있으니, package.json의 engines 필드로 지원 버전을 명시해야 함.

이렇게 하면 호환되지 않는 Node 버전에서 설치 시 경고가 뜨게 됨.

## 모듈 시스템
Node.js는 JavaScript가 아직 공식 모듈 시스템이 없던 시절에 시작됐고, CommonJS(require) 방식을 사용.

이 방식은 서버 사이드 JavaScript에서 코드를 구조화하고 재사용할 수 있게 해준 혁신적인 시스템이었고,

이후 Webpack, Rollup 같은 번들러와 함께 클라이언트 쪽에서도 인기를 얻음.

지금은 JavaScript가 ES 모듈(import/export) 문법을 공식적으로 지원하지만,

Node.js는 브라우저와 다르게 로컬 파일 시스템 기반으로만 모듈을 다루는 구조.

즉, 문법은 같지만 동작 방식은 다르다는 게 핵심.

## 운영체제 기능에 대한 모든 접근
Node.js는 브라우저 밖에서 동작하는 JavaScript 런타임이라, 운영체제의 기능에 직접 접근할 수 있는 모듈들을 제공함.

이 덕분에 서버나 CLI 도구 같은 시스템 수준의 프로그램을 만들 수 있음.

주요 예시는 다음과 같아요:
- fs: 파일 시스템 접근
- net / dgram: TCP, UDP 소켓 통신
- http / https: 웹 서버 생성
- crypto: OpenSSL 기반 암호화 및 해시
- v8 / vm: V8 엔진 내부 접근 및 별도 컨텍스트 실행
- child_process: 외부 프로세스 실행
- process: 현재 실행 중인 프로세스 정보, 환경변수(process.env), 실행 인자(process.argv) 접근
- path : 파일경로나 디렉터리 경로를 다룰 때 (OS간 호환성 고려)
- os : 운영체제 정보 조회 (CPU, 메모리, 플랫폼 등)
- events : 이벤트 기반 프로그래밍을 위한 이벤트 발행/구독 구조
- stream : 데이터 스트림 처리 (파일 읽기/쓰기, 네트워크 스트림 등)
- url : URL 파싱 및 구성
- querystring : URL 쿼리 문자열을 파싱하거나 생성
- buffer : 이진 데이터 처리 (버퍼 객체)
- util : 유틸리티 함수 모음 (디버깅, 콜백 → promise 변환 등)
- zlib : 압축/해제 (gzip, deflate 등)
- dns : DNS 조회 또는 이름해석
- tls : TLS/SSL 기반의 보안통신 설정 (TCP 위에서)
- worker_threads : 워커 스레드를 사용한 멀티스레드 작업
- wasi : WebAssembly System Interface 관련 (WASM 환경 연동)
- module : 모듈 관련 내부 API (module.builtinModules 등)

결국, Node.js는 JavaScript로도 운영체제 레벨의 작업을 수행할 수 있게 해주는 플랫폼이고, 각 기능은 표준 모듈로 잘 정리되어 있음.

## 네이티브 코드 실행
Node.js의 큰 장점 중 하나는 C/C++로 작성된 네이티브 모듈과 직접 연결할 수 있다는 것.

이 기능을 통해 기존 C/C++ 오픈소스나 레거시 시스템을 재사용할 수 있고, 기존 코드를 새로 작성할 필요 없이 바로 활용 가능.

이를 가능하게 하는 인터페이스가 바로 N-API임.

V8 엔진이 매우 빠르지만, 순수 자바스크립트는 네이티브 코드보다 느릴 수 있음.

그래서 CPU 집약적인 연산이나 대용량 데이터 처리는 네이티브 코드로 위임하는 게 효율적.

Node.js와 대부분의 JS VM은 C++이나 Rust 같은 언어를 WASM로 컴파일해서 JS 환경에서도 실행 가능하게 지원.
