# Node.js 플랫폼

## Node.js 철학

1. 경량 코어
    - 최소한의 기능 세트를 제공하며 사용자 전용 모듈 생태계를 둠

2. 경량 모듈
    - 재사용 가능한 라이브러리를 만들기 위한 구성요소
    - npm, yarn등 패키지 매니저를 통해 종속성을 관리

3. 작은 외부 인터페이스
    - 단일진입점을 재공하기위해 단 하나의 함수나 클래스를 노출
    - 모듈의 확장보다는 사용을 위해 모듈 내부 접근을 제한

4. 간결함과 실용주의

## Node.js의 동작원리

### 블로킹 I/O

작업 완료까지 스레드의 실행을 차단

### 논블로킹 I/O

호출 순간에 미리 정의된 상수를 반환, 실제 데이터가 반환될때까지 loop polling (busy waiting)

### 이벤트 디멀티플렉싱

여러 리소스를 관찰하고 이 리소스들 중에 읽기 또는 쓰기 연산의 실행이 완료되었을 때 새로운 이벤트를 반환.
디멀티플렉서가 처리하기 위한 새로운 이벤트가 있을때 까지 프로세스가 블로킹 된다. (CPU를 사용하지 않는다)
    - 이벤트는 커널이 대신 감시하고 프로세스는 유휴상태가 된다.
    - 네트워크가 패킷을 수신하면 하드웨어 인터럽트를 발생시킨다.
    - 커널이 대기 큐에서 프로세스를 찾아 CPU에 스케쥴러에 올린다.

### 리액터 패턴

비동기 작업이 완료됬을떄 각 비동기 작업 완료 후 실행할 핸들러를 갖는다 (콜백을 갖는다)

1. 어플리케이션은 이벤트 디멀티 플렉서에 요청을 전달하여 IO작업을 생성하고, 작업완료시 호출할 핸들러를 명시한다.
    - 이벤트 디멀티플렉서에 새 요청을 전달하는것은 넌블러킹 호출이다. (왜?)
2. 일련의 I/O 작업들이 완료되면 이벤트 디멀티플렉서는 대응하는 이벤트 작업들을 이벤트 큐에 집어넣음
3. 이벤트 루프가 이벤트 큐의 항목을 순회
4. 각 이벤트와 관련된 핸들러가 호출됨
5. 핸들러의 실행이 완료되면 제어권을 이벤트 루프에 반환. 핸들러 실행 중 다른 비동기 작업을 요청할 수 있음 (이벤트 디멀티플렉서에 새로운 항목 추가)
6. 이벤트 큐의 모든 항목이 처리되고 나면 이벤트 루프는 이벤트 디멀티플렉서에서 블로킹 처리되며, 처리가능한 새 이벤트가 있을 경우 다시 트리거됨

### Libuv

각 운영체제별로 논블로킹 동작의 호환을 위해 libuv라는 라이브러리 만듦

## Node.js와 JavaScript

### 모듈 시스템

Node.js는 로컬 파일 시스템에 있는 모듈만 다룰 수 있음

### 운영체제 기능에 대한 모든 접근

fs, net, dgram등의 모듈을 이용해 운영체제 기능에 접근할 수 있음
child_process를 이용하여 다른 프로세스를 실행시키거나, 전역변수 process를 사용하여 프로세스에 할당된 환경변수 목록과 arvg를 가져올 수 있음

### 네이티브 코드 실행

N-API 인터페이스의 도움으로 네이티브 모듈을 구현할 수 있다. (node-canvas)
Javascript VM들은 WASM을 지원한다.

# 비동기-블로킹 I/O 모델이란?

### 동기 I/O

1. 작업 시작
   - Application Thread
     - `read(fileA, buffer, 1024)` 호출 → 시스템 콜 진입
     - 즉시 BLOCKED 상태로 전환
   - Kernel
     - I/O 요청을 수신하고 디스크 컨트롤러에 읽기 명령 전달
     - 해당 스레드를 I/O 대기 큐에 등록
   - CPU
     - 스케줄러가 BLOCKED 스레드를 제외하고 다른 스레드 실행

2. I/O 진행 중
   - Kernel
     - 디스크 I/O 진행
   - Application Thread
     - BLOCKED 상태 유지
   - CPU
     - BLOCKED 스레드는 실행 불가, 다른 태스크로 전환

3. I/O 완료
   - Kernel
     - 디스크 데이터 로드 완료 후 스레드를 RUNNABLE로 변경
   - Application Thread
     - BLOCKED → RUNNABLE → RUNNING (스케줄러에 의해 재실행)
   - CPU
     - 다른 스레드 실행 완료 후 다시 Thread 1을 실행

---

### 비동기 I/O

1. I/O 요청 등록
   - Application Thread
     - 커널에 파일 A 읽기 요청을 등록만 하고 즉시 반환
     - 이후 다른 작업을 병행 수행
   - Kernel
     - 요청을 관심 목록(watch list) 에 등록

2. 이벤트 루프 진입
   - Application Thread
     - `epoll_wait()` 호출로 멀티플렉서 진입
     - ready 리스트가 비어 있다면, 스레드는 BLOCKED 상태로 전환
   - CPU
     - 해당 스레드가 BLOCKED이므로 다른 프로세스/스레드로 전환

3. 백그라운드 I/O 진행
   - Kernel / 하드웨어
     - 드라이버 수준에서 I/O 수행
     - FD에서 이벤트 발생 시 epoll 내부 구조 업데이트 및 ready 리스트 추가
   - Application Thread
     - 커널이 인터럽트를 통해 스레드를 깨움 (BLOCKED → RUNNABLE)

4. I/O 준비 완료 통지 (이벤트 수준)
   - Kernel
     - FD가 "읽기/쓰기 가능" 상태가 되면 epoll ready 목록에 추가
     - 대기 중인 스레드를 깨움 (BLOCKED → RUNNABLE)
   - Application Thread
     - `epoll_wait()`가 리턴하며 이벤트 정보 반환
     - 예: {fd: 3, events: EPOLLIN} - "fd 3번이 읽기 가능"
   
5. 실제 I/O 수행 (데이터 수준)
   - Application Thread
     - 준비된 FD에 대해 실제 `read()/write()` 시스템 콜 수행
     - **이때 논블로킹 모드라면 즉시 리턴**
     - 커널 버퍼 ↔ 사용자 버퍼 간 데이터 복사
   - Kernel
     - 이미 준비된 데이터를 즉시 전달
     - 논블로킹 모드: 가능한 만큼만 읽고 즉시 리턴

6. 디멀티플렉서 및 콜백 처리
   - Application Thread
     - 읽은 데이터를 처리
     - 적절한 비즈니스 로직 콜백 실행

---

### epoll이 스레드를 블로킹하는 시점

epoll은 **이벤트를 기다리는 순간**, 즉 `epoll_wait()` 호출 시에만 스레드를 블로킹한다.
그 외의 모든 순간에는 커널에 요청을 등록만 하고 즉시 반환된다.

---

### epoll의 이벤트 대기 조건
그럼 I/O의 수신 준비완료 조건은 무엇인가?

| I/O 종류 | 커널 상태 | epoll 블로킹 해제 조건 | 실제 read() 동작 |
|---------|---------|-------------------|---------------|
| TCP 수신 | 수신 버퍼 | 1바이트 이상 도착 | 버퍼에 있는 만큼만 읽음 |
| TCP 송신 | 송신 버퍼 | 1바이트 이상 공간 | 가능한 만큼만 씀 |
| UDP 수신 | 수신 큐 | 완전한 데이터그램 1개 | 데이터그램 단위로 읽음 |
| 일반 파일 | 페이지 캐시 | 거의 항상 ready | 요청한 만큼 읽음 (블로킹 가능)* |
| 파이프 | 파이프 버퍼 | 데이터 존재 시 | 버퍼에 있는 만큼 읽음 |

일반 파일 I/O의 경우 대부분 이미 커널 캐시에 존재하므로 거의 항상 “ready” 상태다.

**I/O요청의 시점부터 위의 epoll 블로킹 해제 조건까지 Application Thread가 블로킹 된다.**
---

### 결국 이것도 블로킹이지 않나?

맞다. 동기 I/O든 비동기 I/O든 결국 어느 시점에서는 스레드가 블로킹된다.
차이는 블로킹되는 주체와 범위에 있다.

- 동기 I/O: 요청한 스레드가 개별적으로 블로킹됨 → 많은 컨텍스트 스위칭 발생
- 비동기 I/O: 이벤트 루프 1개만 블로킹 → 수천 개의 I/O를 한 스레드로 처리 가능

즉, “비동기-블로킹 I/O”는 비동기적으로 I/O를 등록하지만,
이벤트 루프 수준에서 블로킹이 존재하는 모델이다.

---

### 그럼 Node.js 관점에서 비동기 I/O란?

Node.js는 libuv 기반의 이벤트 루프를 사용하여 비동기-블로킹 I/O 모델을 구현한다.

- 네트워크 I/O: epoll/kqueue 사용
- 파일 I/O: 스레드 풀 사용 (libuv의 워커 스레드)

Linux의 일반 파일은 epoll에서 항상 "ready"로 나타나므로, 메모리에 파일이 없는 경우 디스크 I/O가 발생한다. = 파일에 대해서는 블로킹일 가능성이 있다.
**따라서 Node.js는 파일을 워커스레드 풀을 이용해 사용읽는다. (워커스레드가 I/O를 담당하고 메인스레드는 논블로킹으로 동작한다.)**
```javascript
// 네트워크: 메인 스레드의 epoll
http.get('example.com', callback);  

// 파일: 워커 스레드 풀 (기본 4개)
fs.readFile('large.txt', callback);
```

- `fs.readFile()`
  → 비동기 호출로, 파일 읽기 요청을 커널에 등록하고 즉시 반환한다.
  → 커널이 I/O를 완료하면 이벤트 루프가 이를 감지하고 콜백을 실행한다.
  → 즉, epoll_wait()이 블로킹되고, 실제 파일 I/O는 백그라운드에서 진행된다.

- `fs.readFileSync()`
  → 동기 호출로, 호출한 스레드가 커널 I/O 완료까지 직접 BLOCKED 된다.
  → 이벤트 루프가 돌지 않으므로, 다른 비동기 작업도 함께 멈춘다.

**요약: Node.js의 비동기 I/O는 내부적으로는 epoll 기반 블로킹 대기, 외부적으로는 논블로킹 API처럼 동작한다.**
