## Proxy && Decorator

노드 진영에서의 proxy와 데코레이터는 거의 동치라고 봐도 된다고 한다. 아래 예시로 존재한다.

```ts
🎯 Node.js에서는 둘 다 “그냥 함수 감싸기”
데코레이터 예 (JS)
function deco(fn) {
  return (...args) => {
    console.log("장식 추가");
    return fn(...args);
  };
}
프록시 예 (JS)
const proxy = new Proxy(obj, {
  get(target, prop) {
    console.log("대리 처리");
    return target[prop];
  }
});

👉 둘 다 겉에서 감싸서 가로채는 방식
👉 개발자 마음대로 조합할 수 있어서 구분이 모호해짐
👉 언어적인 차이가 없어서 사실상 “같은 종류의 기술”
```

```java
// 🎯 Java에서는 구조가 완전 다름
// ⭐ 데코레이터는 “겉에 스킨 씌우기”
class Decorator implements Service {
    private Service next;
    public Decorator(Service next) { this.next = next; }

    public void run() {
        System.out.println("장식 추가");
        next.run();
    }
}
// ⭐ 프록시는 “대리기사” 규칙을 따라야만 함
Service proxy = (Service) Proxy.newProxyInstance(
    Service.class.getClassLoader(),
    new Class[]{Service.class},
    (proxy, method, args) -> {
        System.out.println("대리 처리");
        return method.invoke(realService, args);
    }
);
➡ 완전히 다른 문법
➡ 완전히 다른 구조
➡ Java에서는 누가 봐도 구분됨

👍 한 문장으로 극단적 요약

🟦 Node.js
둘 다 “그냥 감싸기”라서 구분하기가 사실 불가능함.
(동적 언어라 경계가 거의 없음)

🟥 Java
데코레이터는 클래스 구조, 프록시는 인터페이스 기반 대리 호출 구조라 서로 완전 다름.
(정적 언어라 구조가 명확)
```

## Adapter

내 기억대로 책에서도 실제 존재하는 구현체의 사용 방식을 바꿔버리는 방법을 소개한다.

- 사람들이 헷갈려하는 이유 중 하나가 자꾸 "인터페이스"라해서 그런데, 이는 OOP Interface가 아니라 좀 더 범용적인, 그냥 사용 방법 측면에서 어떤 함수가 있냐는 의미의 인터페이스이다 (User Interface와 가까운 이야기)
- 그래서 clean, hexagonal, ddd 에 나오는 어댑터 패턴이랑은 확연히 다르다. 거기는 포트에 여러 어댑터를 끼우는 패턴이며 이는 포트에 어댑터가 어느정도 맞추어주어야할 수 있다. 즉, 어댑터가 좀 더 쓰임을 당하는 입장이다.
  - 그런데, gof 어댑터 패턴은 방향이 반대이다. 원본 클래스/인터페이스가 있고, 이를 어댑터가 쓰고 싶은대로 새로운 인터페이스를 만드는 것이다.
  - 즉, 의존 관점에서 방향성이 신기하게도 완전히 정반대의 패턴인 것이다. gof 어댑터는 주체를 갖고 있고, hexagonal 어댑터는 쓰임을 당하는 느낌이 강하다.
