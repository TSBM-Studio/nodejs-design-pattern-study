# 프록시 패턴
Subject라고 하는 다른 객체에 대한 엑세스를 제어하는 대리자 객체를 제공하는 디자인 패턴임.

Subject에 대해 실행되는 작업의 전부 또는 일부를 가로채서 해당 동작을 증강하거나 보완합니다.

프록시는 다음과 같은 몇 가지 상황에서 유용함.
1. 데이터 검증: 클라이언트가 Subject에 접근하기 전에 입력 데이터를 검증하는 프록시를 구현할 수 있습니다.
2. 보안: 클라이언트가 작업을 수행할 권한이 있는지 확인하고, 권한이 있는 경우에만 요청을 Subject에 전달.
3. 캐싱: 데이터가 아직 캐시에 없는 경우에만 프록시가 Subject에 실행되도록 프록시는 내부에 캐시를 유지함.
4. 느린 초기화: Subject 생성하는데 많은 비용이 드는 경우, 프록시는 실제로 필요할 때까지 이를 지연시킬 수 있음.
5. 기록: 메서드 호출과 관련 매개 변수를 가로채서 발생시 이를 기록함.
6. 원격 프록시: 원격 개체를 가져와서 로컬로 표시할 수 있음.

## 구현 기술
프록시 패턴을 구현하는 방법에는 여러 가지가 있음.

### 객체 컴포지션
기능을 확장해서 사용하기 위해 Subject를 프록시 객체와 결합하는 것.

### 객체 확장
Subject를 상속받아 프록시 객체에서 기능을 확장하는 것. 단, 이 방법은 대상 객체를 직접 변경하기 때문에 위험할 수 있음.

### 내장 프록시 객체
ES2015에서 도입된 Proxy 객체를 사용합니다.

이 객체는 생성자가 대상과 핸들러를 인자로 받아들임.

```js
const calculator = new StackCalculator();

const safeCalculator = new Proxy(calculator, {
      get(target, key) {
          if (typeof key === 'divide') {
              return function () {
                  const divisor = target.peekValue();
                  if (divisor === 0) {
                      throw new Error('0으로 나눌 수 없습니다.');
                  }
                  return target.divide();
              };
          }
          
          return target[key];
      }
});
```

## 프록시를 사용한 변경 옵저버
변경 옵저버 패턴은 Subject가 하나 이상의 옵저버에게 상태 변경을 알리는 디자인 패턴으로 변경 사항이 발생하는 즉시 반응할 수 있음.

# 프록시와 데코레이터 사이의 경계
이 차이점에 대해서 의문이 생길 수 밖에 없음. 두 패턴은 실제로 매우 유사하고 서로 바꿔서 사용할 수 도 있음.

프록시: 원래 객체에 접근하기 전에 검문/감시/지연시키는 역할.

데코레이터: 원래 객체의 기능에 새로운 모듈을 추가하는 역할.

## 프록시
고정적이거나 가상의 객체에 접근을 제어하는데 사용.

대신 객체에 대한 접근을 제어하는데 사용되며 원래의 인터페이스를 변경하지 않음.

그래서 프록시를 만든 후에는 원래 객체를 참조하는 다른 객체들을 안전하게 대체할 수 있음.

## 데코레이터
새로운 동작을 기존의 객체에 추가.

즉, 래퍼로서 볼 수 있음. 다양한 유형의 객체를 가져와 데코레이터로 감싸 추가적인 기능을 추가할 수 있음.

자세한 내용은 데코레이터 예시 참고.

# 어댑터 패턴
어댑터 패턴은 서로 다른 인터페이스를 가진 두 객체 간의 호환성을 제공하는 디자인 패턴임.

어댑터는 클라이언트가 기대하는 인터페이스를 구현하고, 내부적으로는 호환되지 않는 객체를 호출하여 필요한 작업을 수행함.
